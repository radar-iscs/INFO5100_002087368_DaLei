package com.neu.numberrecognizer;

import org.tensorflow.Tensor;
import org.tensorflow.SavedModelBundle;
import org.tensorflow.ndarray.*;
import org.tensorflow.ndarray.Shape;
import org.tensorflow.types.TFloat32;

import javafx.scene.canvas.Canvas;
import javafx.scene.image.WritableImage;
import javafx.embed.swing.SwingFXUtils;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;

public class RecognizerModel {

    private SavedModelBundle model;

    public RecognizerModel() {
        loadModel();
    }

    private void loadModel() {
        try {
            // Load mnist_model generated by Python & TensorFlow
            model = SavedModelBundle.load("mnist_model");
        } catch (Exception e) {
            System.out.println("load mnist_model error: " + e);
            e.printStackTrace();
        }
    }

    public int predictNumber(Canvas canvas) throws IOException {
        // convert canvas image to float array
        float[][][][] imageData = preprocessCanvas(canvas);

        // convert float array to NdArray<Float>
        NdArray<Float> inputNdArray = NdArrays.ofFloats(Shape.of(1, 28, 28, 1));
        for (int i = 0; i < 1; i++) {
            for (int x = 0; x < 28; x++) {
                for (int y = 0; y < 28; y++) {
                    for (int j = 0; j < 1; j++) {
                        ((FloatNdArray) inputNdArray).setFloat(imageData[i][x][y][j], i, x, y, j);
                    }
                }
            }
        }

        // get inputTensor from the NdArray<Float>
        try (Tensor inputTensor = TFloat32.tensorOf(inputNdArray)) {
            // get outputTensor from inputTensor & model
            Tensor outputTensor = model.session().runner()
                    .feed("serving_default_flatten_input:0", inputTensor)
                    .fetch("StatefulPartitionedCall:0")
                    .run().get(0);

            // convert outputTensor to float array
            float[][] outputData = StdArrays.array2dCopyOf((FloatNdArray) outputTensor);

            // get prediction from output array
            int prediction = getPrediction(outputData[0]);

            return prediction;
        }
    }

    private float[][][][] preprocessCanvas(Canvas canvas) throws IOException {
        WritableImage writableImage = new WritableImage(280, 280);
        canvas.snapshot(null, writableImage);
        BufferedImage bufferedImage = SwingFXUtils.fromFXImage(writableImage, null);

        // resize to 28 x 28, according to mnist
        Image tmp = bufferedImage.getScaledInstance(28, 28, Image.SCALE_SMOOTH);
        BufferedImage resized = new BufferedImage(28, 28, BufferedImage.TYPE_BYTE_GRAY);
        Graphics2D g2d = resized.createGraphics();
        g2d.drawImage(tmp, 0, 0, null);
        g2d.dispose();

        // convert to float array
        float[][][][] imageData = new float[1][28][28][1];
        for (int y = 0; y < 28; y++) {
            for (int x = 0; x < 28; x++) {
                int pixel = resized.getRGB(x, y);
                int red = (pixel >> 16) & 0xff;
                float normalized = (255 - red) / 255.0f;
                imageData[0][y][x][0] = 1 - normalized;
            }
        }
        return imageData;
    }

    private int getPrediction(float[] array) {
        int maxIndex = 0;
        float maxValue = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] > maxValue) {
                maxIndex = i;
                maxValue = array[i];
            }
        }
        return maxIndex;
    }
}
